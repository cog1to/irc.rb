diff --git a/irc.rb b/irc.rb
index aa75d6f..a6f5673 100755
--- a/irc.rb
+++ b/irc.rb
@@ -3,6 +3,7 @@
 require "socket"
 require "io/console"
 require 'optparse'
+require "unicode"
 
 ###########
 # Styling #
@@ -559,10 +560,11 @@ class Message
 	end
 
 	def format(cols, user)
-		idx, format, prev, count, tcount = 0, "", "", 0, 0
+		format, prev, count, tcount = 0, "", 0, 0
 		last_break, tlast_break = 0, 0
-		lines, line, s = [], ""
-		prefix_length = 6
+		lines, line = [], ""
+		time = "%02d:%02d " % [@time.hour, @time.min]
+		prefix_length = Unicode::width(time, true)
 		
 		@symbols.each_with_index { |s, i|
 			if s.is_a? FormatSymbol then
@@ -573,6 +575,7 @@ class Message
 			end
 
 			t = s.text
+			tsize = Unicode::width(t, true)
 			is_space = t.match?(/\s+/)
 
 			# Check word boundary.
@@ -581,7 +584,7 @@ class Message
 				last_break = count
 			end
 
-			if count + t.size > cols then
+			if count + tsize > cols then
 				# If there are no break throughout the whole line, break at
 				# current symbol.
 				if last_break == 0 then
@@ -594,15 +597,15 @@ class Message
 				# Next line always starts with padding.
 				line = (" " * prefix_length) + format + left.to_s + (is_space ? "" : t)
 				# Adjust symbol count, ignore space at current symbol.
-				count = prefix_length + left.to_s.size + (is_space ? 0 : t.size)
+				count = prefix_length + Unicode::width(left.to_s, true) + (is_space ? 0 : tsize)
 				tcount = count + format.size
 				# Reset break.
 				last_break = 0
 				tlast_break = 0
 			else
 				line << t
-				count += t.size
-				tcount += t.size
+				count += tsize
+				tcount += tsize
 			end
 		}
 
@@ -755,7 +758,8 @@ class Message
 			end
 
 			idx, format = 0, []
-			while idx < text.length do
+			text = Unicode::text_elements(text.force_encoding("UTF-8"))
+			while idx < text.size do
 				# \003 means changing foreground and background text color.
 				# First, we must get rid of current fg/bg colors.
 				if (text[idx] == "\003") then
@@ -771,7 +775,7 @@ class Message
 					# the new color to apply. Otherwise we're just resetting
 					# the colors to default and re-apply other formatting.
 					style = ""
-					if m = /\A\d\d?(,\d\d?)?/.match(text[idx..-1]) then
+					if m = /\A\d\d?(,\d\d?)?/.match(text[idx..-1].join) then
 						style << Term::from_irc(m[0])
 						format.each { |f| style << SETTINGS[:formatting][f].on }
 						format.append("\003" + m[0])
@@ -1438,8 +1442,9 @@ class App
 		@history = []
 		@history_offset = 0
 		@first_message = true
-		@input_buffer = ""
+		@input_buffer = []
 		@input_offset = 0
+		@symbol_buffer = ""
 
 		# Get current size.
 		size = (`stty size`).split(" ").map { |x| Integer(x) }
@@ -1907,12 +1912,24 @@ class App
 
 		# Draw current content.
 		content = @history_offset < 0 ? @history[@history_offset] : @input_buffer
-		line = content[([0, content.length - @size[:cols] + 4].max)..-1]
-		print("\033[#{@size[:lines]};1H>> #{line}\033[0K")
+		STDERR.puts "content: #{content.join}"
+		# Get how much symbols we can fit
+		max_width = @size[:cols] - 4
+		line, offset = [], -1
+		if Unicode.width(content.join) <= max_width then
+			line = content
+		else
+			while Unicode.width(line.join, true) < max_width && content.length + offset >= 0 do
+				line = content[offset..]
+				offset -= 1
+			end
+		end
+		# Print the input.
+		print("\033[#{@size[:lines]};1H>> #{line.join}\033[0K")
 
 		# Move cursor back.
 		if @input_offset > 0 then
-			print("\033[#{@input_offset}D")
+			print("\033[#{Unicode::width(@input_buffer[-@input_offset..].join, true)}D")
 		end
 	end
 
@@ -2144,7 +2161,7 @@ class App
 			@history_offset = 0
 
 			# Reset buffer and send
-			text, @input_buffer, @input_offset = @input_buffer, "", 0
+			text, @input_buffer, @input_offset = @input_buffer.join, [], 0
 			parse_and_send(text)
 
 			# Redraw the input
@@ -2159,7 +2176,7 @@ class App
 				if @history_offset < 0 then
 					@input_buffer = @history[@history_offset].dup
 				else
-					@input_buffer = ""
+					@input_buffer = []
 				end
 				draw_input
 			when :ARROW_DOWN
@@ -2168,7 +2185,7 @@ class App
 				if @history_offset < 0 then
 					@input_buffer = @history[@history_offset].dup
 				else
-					@input_buffer = ""
+					@input_buffer = []
 				end
 				draw_input
 			when :BACKSPACE
@@ -2219,20 +2236,35 @@ class App
 					redraw
 				end
 			when :ARROW_LEFT
-				old_offset = @input_offset.dup
-				@input_offset = [@input_buffer.length, @input_offset + 1].min
-				print("\033[1D") if (old_offset != @input_offset)
+				old_offset = @input_offset
+				@input_offset = [@input_buffer.size, @input_offset + 1].min
+				if old_offset != @input_offset then
+					console_offset = Unicode::width(@input_buffer[-@input_offset], true)
+					print("\033[#{console_offset}D")
+				end
 			when :ARROW_RIGHT
-				old_offset = @input_offset.dup
-				@input_offset = [0, @input_offset - 1].max
-				print("\033[1C") if (old_offset != @input_offset)
+				old_offset = @input_offset
+				@input_offset = [0, @input_offset - 1].max
+				if old_offset != @input_offset then
+					console_offset = Unicode::width(@input_buffer[-@input_offset-1], true)
+					print("\033[#{console_offset}C")
+				end
 			end
 		}
 
-		@input.on_append = -> (cmd) {
-			@input_buffer.insert(@input_buffer.length - @input_offset, cmd)
-			@history_offset = 0
-			draw_input
+		@input.on_append = -> (x) {
+			@symbol_buffer << x
+			dup = @symbol_buffer.dup.force_encoding("UTF-8")
+
+			if Unicode::width(dup, true) > 0 then
+				@input_buffer.insert(@input_buffer.size - @input_offset, dup)
+				@symbol_buffer = ""
+				# Update input field
+				@history_offset = 0
+				draw_input
+			else
+				STDERR.puts "no input"
+			end
 		}
 	end
 
